name: CD Pipeline

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.github/workflows/ci.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  AWS_REGION: eu-west-1
  DOTNET_VERSION: '9.0.x'
  TF_VERSION: '1.0'
  SOLUTION_PATH: './BPCalculator.sln'
  PROJECT_PATH: './BPCalculator/BPCalculator.csproj'

jobs:
  build-and-package:
    name: Build and Package Application
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-label: ${{ steps.version.outputs.label }}
      artifact-name: ${{ steps.version.outputs.artifact-name }}
      artifact-key: ${{ steps.version.outputs.artifact-key }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
      
      - name: Generate version number
        id: version
        run: |
          VERSION_LABEL="v$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          VERSION="1.0.${{ github.run_number }}"
          ARTIFACT_KEY="bp-app-${VERSION_LABEL}.zip"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "label=${VERSION_LABEL}" >> $GITHUB_OUTPUT
          echo "artifact-name=deployment-package" >> $GITHUB_OUTPUT
          echo "artifact-key=${ARTIFACT_KEY}" >> $GITHUB_OUTPUT
          echo "üì¶ Version: ${VERSION}"
          echo "üì¶ Label: ${VERSION_LABEL}"
          echo "üì¶ Artifact Key: ${ARTIFACT_KEY}"
      
      - name: Restore dependencies
        run: dotnet restore ${{ env.SOLUTION_PATH }}
      
      - name: Build application
        run: dotnet build ${{ env.SOLUTION_PATH }} -c Release --no-restore
      
      - name: Run tests
        run: dotnet test ${{ env.SOLUTION_PATH }} -c Release --no-build --verbosity minimal
      
      - name: Publish application
        run: |
          dotnet publish ${{ env.PROJECT_PATH }} \
            -c Release \
            -o ./publish \
            --no-build
      
      - name: Create deployment package
        run: |
          cd ./publish
          zip -r ../${{ steps.version.outputs.artifact-key }} .
          cd ..
          echo "üì¶ Package: ${{ steps.version.outputs.artifact-key }}"
          echo "üì¶ Size: $(du -h ${{ steps.version.outputs.artifact-key }} | cut -f1)"
      
      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.version.outputs.artifact-name }}
          path: ${{ steps.version.outputs.artifact-key }}
          retention-days: 30

  deploy-infrastructure-staging:
    name: Deploy Infrastructure (Staging)
    runs-on: ubuntu-latest
    needs: build-and-package
    outputs:
      application-name: ${{ steps.tf-outputs.outputs.app-name }}
      environment-name: ${{ steps.tf-outputs.outputs.env-name }}
      s3-bucket: ${{ steps.tf-outputs.outputs.s3-bucket }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      - name: Terraform Init (Staging)
        working-directory: ./infra
        run: |
          echo "üîß Initializing Terraform for staging environment..."
          terraform init \
            -backend-config="bucket=bp-terraform-state-431774613177" \
            -backend-config="key=staging/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=bp-terraform-locks"
      
      - name: Terraform Plan (Staging)
        working-directory: ./infra
        run: |
          echo "üìã Planning infrastructure changes for staging..."
          terraform plan \
            -var="environment=staging" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -out=tfplan
      
      - name: Terraform Apply (Staging)
        working-directory: ./infra
        run: |
          echo "üöÄ Applying infrastructure changes for staging..."
          terraform apply -auto-approve tfplan
          echo "‚úÖ Infrastructure deployment complete"
      
      - name: Get Terraform Outputs
        id: tf-outputs
        working-directory: ./infra
        run: |
          APP_NAME=$(terraform output -raw application_name)
          ENV_NAME=$(terraform output -raw environment_name)
          S3_BUCKET=$(terraform output -raw app_versions_bucket)
          
          echo "app-name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "env-name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "s3-bucket=${S3_BUCKET}" >> $GITHUB_OUTPUT
          
          echo "## üèóÔ∏è Infrastructure Outputs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** ${APP_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${ENV_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket:** ${S3_BUCKET}" >> $GITHUB_STEP_SUMMARY

  deploy-application-staging:
    name: Deploy Application (Staging)
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-infrastructure-staging]
    environment:
      name: staging
      url: ${{ steps.get-url.outputs.environment-url }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-and-package.outputs.artifact-name }}
      
      - name: Upload to S3
        id: s3-upload
        run: |
          ARTIFACT_KEY="${{ needs.build-and-package.outputs.artifact-key }}"
          VERSION_LABEL="${{ needs.build-and-package.outputs.version-label }}"
          S3_BUCKET="${{ needs.deploy-infrastructure-staging.outputs.s3-bucket }}"
          S3_KEY="applications/bp-calculator/${ARTIFACT_KEY}"
          
          echo "üì¶ Uploading ${ARTIFACT_KEY} to s3://${S3_BUCKET}/${S3_KEY}"
          aws s3 cp "${ARTIFACT_KEY}" "s3://${S3_BUCKET}/${S3_KEY}"
          
          echo "s3-key=${S3_KEY}" >> $GITHUB_OUTPUT
          echo "‚úÖ Uploaded to S3"
      
      - name: Create Elastic Beanstalk Application Version
        id: create-version
        run: |
          VERSION_LABEL="${{ needs.build-and-package.outputs.version-label }}"
          S3_KEY="${{ steps.s3-upload.outputs.s3-key }}"
          APP_NAME="${{ needs.deploy-infrastructure-staging.outputs.application-name }}"
          S3_BUCKET="${{ needs.deploy-infrastructure-staging.outputs.s3-bucket }}"
          
          echo "üì¶ Creating EB application version: ${VERSION_LABEL}"
          aws elasticbeanstalk create-application-version \
            --application-name "${APP_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --source-bundle S3Bucket="${S3_BUCKET}",S3Key="${S3_KEY}" \
            --description "Build ${{ github.run_number }} - Commit ${GITHUB_SHA:0:7}" \
            --region ${{ env.AWS_REGION }}
          
          echo "version-label=${VERSION_LABEL}" >> $GITHUB_OUTPUT
          echo "‚úÖ Created version: ${VERSION_LABEL}"
      
      - name: Deploy to Elastic Beanstalk
        id: deploy
        run: |
          VERSION_LABEL="${{ steps.create-version.outputs.version-label }}"
          APP_NAME="${{ needs.deploy-infrastructure-staging.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-staging.outputs.environment-name }}"
          
          echo "üöÄ Deploying ${VERSION_LABEL} to staging..."
          aws elasticbeanstalk update-environment \
            --application-name "${APP_NAME}" \
            --environment-name "${ENV_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for environment to be ready..."
      
      - name: Wait for deployment
        run: |
          APP_NAME="${{ needs.deploy-infrastructure-staging.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-staging.outputs.environment-name }}"
          
          echo "‚è≥ Waiting for staging environment to be ready..."
          aws elasticbeanstalk wait environment-updated \
            --application-name "${APP_NAME}" \
            --environment-name "${ENV_NAME}" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Staging deployment completed"
      
      - name: Get environment URL
        id: get-url
        run: |
          APP_NAME="${{ needs.deploy-infrastructure-staging.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-staging.outputs.environment-name }}"
          
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --application-name "${APP_NAME}" \
            --environment-names "${ENV_NAME}" \
            --query "Environments[0].CNAME" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "environment-url=http://${ENV_URL}" >> $GITHUB_OUTPUT
          echo "üåê Staging URL: http://${ENV_URL}"
      
      - name: Health check
        run: |
          ENV_URL="${{ steps.get-url.outputs.environment-url }}"
          echo "üè• Running health check on ${ENV_URL}"
          
          for i in {1..10}; do
            if curl -f -s -o /dev/null -w "%{http_code}" "${ENV_URL}" | grep -q "200"; then
              echo "‚úÖ Health check passed (attempt $i)"
              exit 0
            fi
            echo "‚è≥ Waiting for application to be ready (attempt $i/10)..."
            sleep 30
          done
          
          echo "‚ùå Health check failed after 10 attempts"
          exit 1
      
      - name: Deployment summary
        run: |
          echo "## üéâ Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | Staging |" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | ${{ needs.build-and-package.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Application** | ${{ steps.tf-outputs.outputs.app-name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **EB Environment** | ${{ steps.tf-outputs.outputs.env-name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **URL** | ${{ steps.get-url.outputs.environment-url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Deployment successful and health check passed" >> $GITHUB_STEP_SUMMARY

  test-staging:
    name: Test Staging Environment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure-staging, deploy-application-staging]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get staging URL
        id: get-url
        run: |
          APP_NAME="${{ needs.deploy-infrastructure-staging.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-staging.outputs.environment-name }}"
          
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --application-name "${APP_NAME}" \
            --environment-names "${ENV_NAME}" \
            --query "Environments[0].CNAME" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "staging-url=http://${ENV_URL}" >> $GITHUB_OUTPUT
          echo "üß™ Testing: http://${ENV_URL}"
      
      - name: Smoke tests
        run: |
          URL="${{ steps.get-url.outputs.staging-url }}"
          
          echo "üß™ Running smoke tests..."
          
          # Test 1: Homepage loads
          echo "Test 1: Homepage returns 200"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${URL}")
          if [ "$STATUS" = "200" ]; then
            echo "‚úÖ Homepage test passed"
          else
            echo "‚ùå Homepage test failed (status: $STATUS)"
            exit 1
          fi
          
          # Test 2: Homepage contains expected content
          echo "Test 2: Homepage contains 'Blood Pressure'"
          if curl -s "${URL}" | grep -q "Blood Pressure"; then
            echo "‚úÖ Content test passed"
          else
            echo "‚ùå Content test failed"
            exit 1
          fi
          
          # Test 3: Static resources load
          echo "Test 3: CSS loads successfully"
          CSS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${URL}/css/site.css")
          if [ "$CSS_STATUS" = "200" ]; then
            echo "‚úÖ Static resources test passed"
          else
            echo "‚ö†Ô∏è  CSS might not be loading (status: $CSS_STATUS)"
          fi
          
          echo "‚úÖ All smoke tests passed"
      
      - name: Performance check
        run: |
          URL="${{ steps.get-url.outputs.staging-url }}"
          
          echo "‚ö° Running performance check..."
          
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${URL}")
          echo "Response time: ${RESPONSE_TIME}s"
          
          # Check if response time is under 5 seconds
          if (( $(echo "$RESPONSE_TIME < 5.0" | bc -l) )); then
            echo "‚úÖ Performance check passed (${RESPONSE_TIME}s < 5s)"
          else
            echo "‚ö†Ô∏è  Response time is slow: ${RESPONSE_TIME}s"
          fi
      
      - name: Test summary
        run: |
          echo "## üß™ Staging Tests Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Smoke tests passed" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Performance check passed" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Environment is ready for production promotion" >> $GITHUB_STEP_SUMMARY

  deploy-infrastructure-production:
    name: Deploy Infrastructure (Production)
    runs-on: ubuntu-latest
    needs: [build-and-package, test-staging]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
    outputs:
      application-name: ${{ steps.tf-outputs.outputs.app-name }}
      environment-name: ${{ steps.tf-outputs.outputs.env-name }}
      s3-bucket: ${{ steps.tf-outputs.outputs.s3-bucket }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      - name: Terraform Init (Production)
        working-directory: ./infra
        run: |
          echo "üîß Initializing Terraform for production environment..."
          terraform init \
            -backend-config="bucket=bp-terraform-state-431774613177" \
            -backend-config="key=production/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=bp-terraform-locks"
      
      - name: Terraform Plan (Production)
        working-directory: ./infra
        run: |
          echo "üìã Planning infrastructure changes for production..."
          terraform plan \
            -var="environment=production" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="min_instances=2" \
            -var="max_instances=4" \
            -out=tfplan
      
      - name: Terraform Apply (Production)
        working-directory: ./infra
        run: |
          echo "üöÄ Applying infrastructure changes for production..."
          terraform apply -auto-approve tfplan
          echo "‚úÖ Infrastructure deployment complete"
      
      - name: Get Terraform Outputs
        id: tf-outputs
        working-directory: ./infra
        run: |
          APP_NAME=$(terraform output -raw application_name)
          ENV_NAME=$(terraform output -raw environment_name)
          S3_BUCKET=$(terraform output -raw app_versions_bucket)
          
          echo "app-name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "env-name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "s3-bucket=${S3_BUCKET}" >> $GITHUB_OUTPUT
          
          echo "## üèóÔ∏è Infrastructure Outputs (Production)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** ${APP_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${ENV_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket:** ${S3_BUCKET}" >> $GITHUB_STEP_SUMMARY

  deploy-application-production:
    name: Deploy Application (Production)
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-infrastructure-production]
    environment:
      name: production
      url: ${{ steps.get-url.outputs.environment-url }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-and-package.outputs.artifact-name }}
      
      - name: Upload to S3 (if not exists)
        id: s3-upload
        run: |
          ARTIFACT_KEY="${{ needs.build-and-package.outputs.artifact-key }}"
          VERSION_LABEL="${{ needs.build-and-package.outputs.version-label }}"
          S3_BUCKET="${{ needs.deploy-infrastructure-production.outputs.s3-bucket }}"
          S3_KEY="applications/bp-calculator/${ARTIFACT_KEY}"
          
          # Check if already uploaded (from staging deployment - different S3 bucket per environment)
          if aws s3 ls "s3://${S3_BUCKET}/${S3_KEY}" > /dev/null 2>&1; then
            echo "‚ÑπÔ∏è  Artifact already exists in S3"
          else
            echo "üì¶ Uploading ${ARTIFACT_KEY} to s3://${S3_BUCKET}/${S3_KEY}"
            aws s3 cp "${ARTIFACT_KEY}" "s3://${S3_BUCKET}/${S3_KEY}"
          fi
          
          echo "s3-key=${S3_KEY}" >> $GITHUB_OUTPUT
          echo "‚úÖ S3 upload verified"
      
      - name: Create Elastic Beanstalk Application Version
        id: create-version
        run: |
          VERSION_LABEL="${{ needs.build-and-package.outputs.version-label }}"
          S3_KEY="${{ steps.s3-upload.outputs.s3-key }}"
          APP_NAME="${{ needs.deploy-infrastructure-production.outputs.application-name }}"
          S3_BUCKET="${{ needs.deploy-infrastructure-production.outputs.s3-bucket }}"
          
          # Check if version already exists (created during staging deployment)
          if aws elasticbeanstalk describe-application-versions \
            --application-name "${APP_NAME}" \
            --version-labels "${VERSION_LABEL}" \
            --region ${{ env.AWS_REGION }} | grep -q "${VERSION_LABEL}"; then
            echo "‚ÑπÔ∏è  Version ${VERSION_LABEL} already exists"
          else
            echo "üì¶ Creating EB application version: ${VERSION_LABEL}"
            aws elasticbeanstalk create-application-version \
              --application-name "${APP_NAME}" \
              --version-label "${VERSION_LABEL}" \
              --source-bundle S3Bucket="${S3_BUCKET}",S3Key="${S3_KEY}" \
              --description "Production Build ${{ github.run_number }} - Commit ${GITHUB_SHA:0:7}" \
              --region ${{ env.AWS_REGION }}
            echo "‚úÖ Created version: ${VERSION_LABEL}"
          fi
          
          echo "version-label=${VERSION_LABEL}" >> $GITHUB_OUTPUT
          echo "‚úÖ Application version ready: ${VERSION_LABEL}"
      
      - name: Deploy to Production
        run: |
          VERSION_LABEL="${{ steps.create-version.outputs.version-label }}"
          APP_NAME="${{ needs.deploy-infrastructure-production.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-production.outputs.environment-name }}"
          
          echo "üöÄ Deploying ${VERSION_LABEL} to production..."
          aws elasticbeanstalk update-environment \
            --application-name "${APP_NAME}" \
            --environment-name "${ENV_NAME}" \
            --version-label "${VERSION_LABEL}" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for environment to be ready..."
      
      - name: Wait for deployment
        run: |
          APP_NAME="${{ needs.deploy-infrastructure-production.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-production.outputs.environment-name }}"
          
          echo "‚è≥ Waiting for production environment to be ready..."
          aws elasticbeanstalk wait environment-updated \
            --application-name "${APP_NAME}" \
            --environment-name "${ENV_NAME}" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Production deployment completed"
      
      - name: Get environment URL
        id: get-url
        run: |
          APP_NAME="${{ needs.deploy-infrastructure-production.outputs.application-name }}"
          ENV_NAME="${{ needs.deploy-infrastructure-production.outputs.environment-name }}"
          
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --application-name "${APP_NAME}" \
            --environment-names "${ENV_NAME}" \
            --query "Environments[0].CNAME" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "environment-url=http://${ENV_URL}" >> $GITHUB_OUTPUT
          echo "üåê Production URL: http://${ENV_URL}"
      
      - name: Production health check
        run: |
          ENV_URL="${{ steps.get-url.outputs.environment-url }}"
          echo "üè• Running production health check on ${ENV_URL}"
          
          for i in {1..15}; do
            if curl -f -s -o /dev/null -w "%{http_code}" "${ENV_URL}" | grep -q "200"; then
              echo "‚úÖ Production health check passed (attempt $i)"
              exit 0
            fi
            echo "‚è≥ Waiting for application to be ready (attempt $i/15)..."
            sleep 30
          done
          
          echo "‚ùå Production health check failed after 15 attempts"
          exit 1
      
      - name: Production deployment summary
        run: |
          echo "## üéâ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | üî¥ Production |" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | ${{ needs.build-and-package.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Application** | ${{ steps.tf-outputs.outputs.app-name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **EB Environment** | ${{ steps.tf-outputs.outputs.env-name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **URL** | ${{ steps.get-url.outputs.environment-url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Production deployment successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor application metrics in CloudWatch" >> $GITHUB_STEP_SUMMARY
          echo "- Check application logs for any errors" >> $GITHUB_STEP_SUMMARY
          echo "- Verify all features are working as expected" >> $GITHUB_STEP_SUMMARY

  pipeline-complete:
    name: Pipeline Complete
    runs-on: ubuntu-latest
    needs: [build-and-package, deploy-infrastructure-staging, deploy-application-staging, test-staging, deploy-infrastructure-production, deploy-application-production]
    if: always()
    
    steps:
      - name: Pipeline summary
        run: |
          echo "# üéâ CD Pipeline Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Package | ${{ needs.build-and-package.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Infrastructure (Staging) | ${{ needs.deploy-infrastructure-staging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Application (Staging) | ${{ needs.deploy-application-staging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Test Staging | ${{ needs.test-staging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Infrastructure (Production) | ${{ needs.deploy-infrastructure-production.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Application (Production) | ${{ needs.deploy-application-production.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.build-and-package.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
      
      - name: Check pipeline status
        run: |
          if [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "‚úÖ Full pipeline completed successfully!"
            exit 0
          elif [ "${{ needs.test-staging.result }}" = "success" ]; then
            echo "‚úÖ Staging deployment completed successfully!"
            exit 0
          else
            echo "‚ùå Pipeline had failures"
            exit 1
          fi
